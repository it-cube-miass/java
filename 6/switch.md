Оператор switch состоит из выражения и тела, которое содержит различные пронумерованные точки входа. Выражение вычисляется, и управление переходит на точку входа, определенную полученным значением. Выражение должно возвращать следующие тип данных: *int*, *short*, *char*, *byte* (или их обертки), *String* или *enum*.

Общая форма оператора switch имеет следующий вид:

![рис. 6-3](assets/6-3.png)

Часто он оказывается эффективнее применения длинных последовательностей операторов if-else-if. Например, последний код из темы **if/else* можно переписать таким образом:
```java
switch(n) {
  case 1: {
    // Выполнить блок кода №1
    break;
  }
  case 2: {
    // Выполнить блок кода №2
    break;
  }
  case 3: {
    // Выполнить блок кода №3
    break;
  }
  default: {
    // Если ни одно условие не выполнилось, выполнить блок №4
  }
}
```
При выполнении оператора switch интерпретатор вычисляет значение выражения в круглых скобках, а затем ищет метку case, соответствующую полученному значению. Если интерпретатор находит метку, он начинает выполнять блок программы с первого оператора после метки case. Если интерпретатор не находит метку case с соответствующим значением, он начинает выполнение блока с первого оператора после специальной метки default:. Или ничего не выполняет, раз не нашлось подходящей метки.

Обратите внимание на использование ключевого слова *break* в конце каждого *case* в предыдущем примере. Оператор *break* будет описан чуть позже; в данном случае он заставляет интерпретатор покинуть оператор *switch*. Метки *case* определяют только начальную точку нужного кода. Отдельные варианты не являются независимыми блоками программы и не содержат никакой неявной точки окончания. Поэтому при помощи оператора *break* или другого подходящего оператора нужно явно определить окончание каждого варианта. Если нет оператора *break*, оператор switch начинает выполнять код с первого оператора после соответствующей метки *case* и продолжает выполнять операторы, пока не достигнет конца блока.  
Иногда удобно писать код с последовательным переходом от одной метки case к другой, однако в 99% случаев вам придется завершать каждый раздел *case* и default оператором, приводящим к завершению выполнения оператора *switch*. Обычно в таких случаях применяют оператор *break*, но также подходят *return* и *throw*. Как только программа доходит до оператора *break* (*return*, *throw*), она продолжает выполнение с первой строки кода, следующей за всем оператором *switch*.

Оператор *switch* может содержать более одной метки case для одного и того же оператора. По существу это использование нескольких операторов *case* без разделяющих их операторов *break*.
```java
switch(value) {
  case "Y":
  case "Yes":
  case "y": {
    System.out.println("Да!");
    break;
  }
  case "N":
  case "No":
  case "n": {
    System.out.println("Нет!");
    break;
  }
  default: 
    throw new IllegalArgumentException("значение должно быть Y или N");
}
```
Есть несколько важных ограничений для оператора *switch* и его меток case.  
Во-первых типы с плавающей точкой и *boolean* не поддерживаются. То же самое относится к *long*, хотя *long* является целым типом. Во-вторых, значение, ассоциируемое с каждой меткой *case*, должно быть постоянным значением или выражением, которое может вычислить компилятор. Например, метка *case* не может содержать выражение, вычисляемое во время выполнения – с переменными и вызовами методов. В-третьих, значения меток *case* должны соответствовать типу данных выражения *switch*. И наконец, не разрешается создавать две и более метки *case* с одинаковым значением или больше одной метки *default*.

## Вложенные операторы switch
Оператор *switch* можно использовать в последовательности операторов внешнего оператора *switch*. Такой оператор называют вложенным оператором *switch*. Поскольку оператор *switch* определяет собственный блок, каких-либо конфликтов между константами *case* внутреннего и внешнего операторов *switch* не происходит. Например, следующий фрагмент полностью допустим:
```java
switch(count) {
  case 1: 
    switch(target) {
      case 0: System.out.println("target равна 0"); break;
      case 1: System.out.println("target равна 1"); break;
    }
    break;
  case 2: 
    //...
}
```
В данном случае оператор ```case 1:``` внутреннего оператора *switch* не конфликтует с оператором ```case 1:``` внешнего оператора *switch*. Программа сравнивает значение переменной count только со списком ветвей case внешнего уровня. Если значение count равно 1, программа сравнивает значение переменной ```target``` c внутренним списком ветвей *case*.

Ну и на последок можно сказать, что как правило, оператор *switch* эффективнее набора вложенных операторов *if*. Это свойство представляет особый интерес, поскольку позволяет понять работу компилятора Java. Компилируя оператор switch, компилятор Java будет проверять каждую из констант *case* и создавать "таблицу переходов", которую будет использовать для выбора ветви программы в зависимости от значения выражения. Поэтому в тех случаях, когда требуется осуществлять выбор в большой группе значений, оператор *switch* будет выполняться значительно быстрее последовательности операторов *if/else*. Это обусловлено тем, что компилятору известно, что все константы *case* имеют один и тот же тип, и их нужно просто проверять на предмет равенства значению выражения *switch*. Компилятор не располагает подобными сведениями в длинном списке выражений оператора *if*.
